declare class Crypto {

  getRandomValues(
    typedArray: Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array
  ): void;

}

declare var crypto: Crypto;
interface EventInit {
  bubbles?: boolean;
  cancelable?: boolean;
}

interface Event {
  readonly bubbles: boolean;
  readonly cancelable: boolean;
  readonly currentTarget: EventTarget;
  readonly defaultPrevented: boolean;
  readonly eventPhase: number;
  readonly isTrusted: boolean;
  readonly target: EventTarget;
  readonly timeStamp: number;
  readonly type: string;
  initEvent(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean): void;
  preventDefault(): void;
  stopImmediatePropagation(): void;
  stopPropagation(): void;
  readonly AT_TARGET: number;
  readonly BUBBLING_PHASE: number;
  readonly CAPTURING_PHASE: number;
}

declare var Event: {
  prototype: Event;
  new(typeArg: string, eventInitDict?: EventInit): Event;
  readonly AT_TARGET: number;
  readonly BUBBLING_PHASE: number;
  readonly CAPTURING_PHASE: number;
}

interface EventListener {
  (evt: Event): void;
}

interface EventTarget {
  addEventListener(type: string, listener?: EventListener, useCapture?: boolean): void;
  dispatchEvent(evt: Event): boolean;
  removeEventListener(type: string, listener?: EventListener, useCapture?: boolean): void;
}

declare var EventTarget: {
  prototype: EventTarget;
  new(): EventTarget;
}

interface ProgressEventInit extends EventInit {
  lengthComputable?: boolean;
  loaded?: number;
  total?: number;
}

interface ProgressEvent extends Event {
  readonly lengthComputable: boolean;
  readonly loaded: number;
  readonly total: number;
  initProgressEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, lengthComputableArg: boolean, loadedArg: number, totalArg: number): void;
}

declare var ProgressEvent: {
  prototype: ProgressEvent;
  new(type: string, eventInitDict?: ProgressEventInit): ProgressEvent;
}

interface ErrorEventInit extends EventInit {
  message?: string;
  filename?: string;
  lineno?: number;
  colno?: number;
  error?: any;
}

interface ErrorEvent extends Event {
  readonly colno: number;
  readonly error: any;
  readonly filename: string;
  readonly lineno: number;
  readonly message: string;
  initErrorEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, messageArg: string, filenameArg: string, linenoArg: number): void;
}

declare var ErrorEvent: {
  prototype: ErrorEvent;
  new(type: string, errorEventInitDict?: ErrorEventInit): ErrorEvent;
}

interface CloseEventInit extends EventInit {
  wasClean?: boolean;
  code?: number;
  reason?: string;
}

interface CloseEvent extends Event {
  readonly code: number;
  readonly reason: string;
  readonly wasClean: boolean;
  initCloseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, wasCleanArg: boolean, codeArg: number, reasonArg: string): void;
}

declare var CloseEvent: {
  prototype: CloseEvent;
  new(typeArg: string, eventInitDict?: CloseEventInit): CloseEvent;
}


interface MessageEventInit extends EventInit {
  lastEventId?: string;
  channel?: string;
  data?: any;
  origin?: string;
  source?: any;
  ports?: MessagePort[];
}

interface MessageEvent extends Event {
  readonly data: any;
  readonly origin: string;
  readonly ports: any;
  readonly source: any;
  initMessageEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, dataArg: any, originArg: string, lastEventIdArg: string, sourceArg: any): void;
}

declare var MessageEvent: {
  prototype: MessageEvent;
  new(type: string, eventInitDict?: MessageEventInit): MessageEvent;
}

declare var MessageEvent: {
  prototype: MessageEvent;
  new(type: string, eventInitDict?: MessageEventInit): MessageEvent;
}

interface MessagePortEventMap {
  "message": MessageEvent;
}

interface MessagePort extends EventTarget {
  onmessage: (this: MessagePort, ev: MessageEvent) => any;
  close(): void;
  postMessage(message?: any, transfer?: any[]): void;
  start(): void;
  addEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, useCapture?: boolean): void;
}

declare var MessagePort: {
  prototype: MessagePort;
  new(): MessagePort;
}


interface CordovaPlugins {}

interface Navigator {}

interface Document {}

interface Cordova {
  plugins: CordovaPlugins;
}

interface Window {
  plugins: CordovaPlugins;
  cordova: Cordova;
  navigator: Navigator;
  window: Window;
  document: Document;
}

declare var navigator: Navigator;
declare var window: Window;
declare var document: Document;
declare var plugins: CordovaPlugins;
declare var cordova: Cordova;

/**
 * Represents pixel data of a `Canvas` widget.
 */
declare class ImageData {

  constructor(data: Uint8ClampedArray, width: number, height?: number);
  constructor(width: number, height: number);

  /**
   * A one-dimensional array containing the data in RGBA order, with integer values between 0 and 255 (inclusive).
   */
  readonly data: Uint8ClampedArray;

  /**
   * The actual height of the ImageData, in pixels.
   */
  readonly width: number;

  /**
   * The actual height of the ImageData, in pixels.
   */
  readonly height: number;

}
declare namespace JSX {

  type JsxFactory = (
    this: object,
    type: {new (...args: any[]): any },
    attributes: object
  ) => Element;

  type Element = any;

  const jsxFactory: unique symbol;
  const jsxType: unique symbol;

  function createElement(type: Function|string, attributes: object, ...children: Array<ElementClass>): ElementClass;

  function install(jsxProcessor: tabris.JsxProcessor): void;

  interface ElementClass {
    jsxAttributes?: object;
    [JSX.jsxFactory]: JsxFactory;
  }

  interface ElementAttributesProperty {
    jsxAttributes: any;
  }

  interface ElementChildrenAttribute {
    children?: any;
  }

  interface IntrinsicElements {
    br: {children?: never};
    b: {children?: string|string[]};
    span: {children?: string|string[]};
    big: {children?: string|string[]};
    i: {children?: string|string[]};
    small: {children?: string|string[]};
    strong: {children?: string|string[]};
    ins: {children?: string|string[]};
    del: {children?: string|string[]};
    a: {href?: string, children?: string|string[]};
  }

}

declare var secureStorage: Storage;
declare var device: tabris.Device;
declare var __dirname: string;
declare var __filename: string;
declare var module: tabris.Module;
declare var exports: object;
declare var require: (request: string) => object;
interface WebSocketEventMap {
    "close": CloseEvent;
    "error": Event;
    "message": MessageEvent;
    "open": Event;
}

interface WebSocket extends EventTarget {
    binaryType: string;
    readonly bufferedAmount: number;
    readonly extensions: string;
    onclose: (this: WebSocket, ev: CloseEvent) => any;
    onerror: (this: WebSocket, ev: Event) => any;
    onmessage: (this: WebSocket, ev: MessageEvent) => any;
    onopen: (this: WebSocket, ev: Event) => any;
    readonly protocol: string;
    readonly readyState: number;
    readonly url: string;
    close(code?: number, reason?: string): void;
    send(data: any): void;
    readonly CLOSED: number;
    readonly CLOSING: number;
    readonly CONNECTING: number;
    readonly OPEN: number;
    addEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, useCapture?: boolean): void;
}

declare var WebSocket: {
    prototype: WebSocket;
    new(url: string, protocols?: string | string[]): WebSocket;
    readonly CLOSED: number;
    readonly CLOSING: number;
    readonly CONNECTING: number;
    readonly OPEN: number;
}

// Type definitions for fetch API
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/56295f5058cac7ae458540423c50ac2dcf9fc711/whatwg-fetch/whatwg-fetch.d.ts
// Project: https://github.com/github/fetch
// Definitions by: Ryan Graham <https://github.com/ryan-codingintrigue>

declare class Request extends Body {
  constructor(input: string | Request, init?: RequestInit);
  method: string;
  url: string;
  headers: Headers;
  context: RequestContext;
  referrer: string;
  mode: RequestMode;
  credentials: RequestCredentials;
  cache: RequestCache;
}

interface RequestInit {
  method?: string;
  headers?: HeaderInit | { [index: string]: string };
  body?: BodyInit;
  mode?: RequestMode;
  credentials?: RequestCredentials;
  cache?: RequestCache;
}

type RequestContext =
  "audio" | "beacon" | "cspreport" | "download" | "embed" |
  "eventsource" | "favicon" | "fetch" | "font" | "form" | "frame" |
  "hyperlink" | "iframe" | "image" | "imageset" | "import" |
  "internal" | "location" | "manifest" | "object" | "ping" | "plugin" |
  "prefetch" | "script" | "serviceworker" | "sharedworker" |
  "subresource" | "style" | "track" | "video" | "worker" |
  "xmlhttprequest" | "xslt";
type RequestMode = "same-origin" | "no-cors" | "cors";
type RequestCredentials = "omit" | "same-origin" | "include";
type RequestCache =
  "default" | "no-store" | "reload" | "no-cache" |
  "force-cache" | "only-if-cached";

declare class Headers {
  append(name: string, value: string): void;
  delete(name: string): void;
  get(name: string): string;
  getAll(name: string): Array<string>;
  has(name: string): boolean;
  set(name: string, value: string): void;
  forEach(callback: (value: string, name: string) => void): void;
}

declare class Body {
  bodyUsed: boolean;
  arrayBuffer(): Promise<ArrayBuffer>;
  // TODO: enable when Blob support is added
  // blob(): Promise<Blob>;
  // formData(): Promise<FormData>;
  json(): Promise<any>;
  json<T>(): Promise<T>;
  text(): Promise<string>;
}
declare class Response extends Body {
  constructor(body?: BodyInit, init?: ResponseInit);
  error(): Response;
  redirect(url: string, status: number): Response;
  type: ResponseType;
  url: string;
  status: number;
  ok: boolean;
  statusText: string;
  headers: Headers;
  clone(): Response;
}

type ResponseType = "basic" | "cors" | "default" | "error" | "opaque";

interface ResponseInit {
  status: number;
  statusText?: string;
  headers?: HeaderInit;
}

declare type HeaderInit = Headers | Array<string>;
// TODO: enable when Blob support is added
// declare type BodyInit = Blob | FormData | string;
declare type BodyInit = string;
declare type RequestInfo = Request | string;

declare function fetch(url: string | Request, init?: RequestInit): Promise<Response>;

interface WorkerEventMap {
    "message": MessageEvent;
    "error": Event;
    "messageerror": Event;
}

interface Worker extends EventTarget {
    onerror: (this: Worker, ev: Event) => any;
    onmessageerror: (this: Worker, ev: Event) => any;
    onmessage: (this: Worker, ev: MessageEvent) => any;
    onopen: (this: Worker, ev: Event) => any;
    readonly protocol: string;
    readonly readyState: number;
    readonly url: string;
    postMessage(data: any, transferList?: Array<any>): void;
    terminate(): void;
    addEventListener<K extends keyof WorkerEventMap>(type: K, listener: (this: Worker, ev: WorkerEventMap[K]) => any, useCapture?: boolean): void;
}

declare var Worker: {
    prototype: Worker;
    new(scriptPath: string): Worker;
};

interface XMLHttpRequestEventTarget {
    onabort: (this: XMLHttpRequestEventTarget, ev: Event) => any;
    onerror: (this: XMLHttpRequestEventTarget, ev: ErrorEvent) => any;
    onload: (this: XMLHttpRequestEventTarget, ev: Event) => any;
    onloadend: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;
    onloadstart: (this: XMLHttpRequestEventTarget, ev: Event) => any;
    onprogress: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;
    ontimeout: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;
    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, useCapture?: boolean): void;
    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
}

interface XMLHttpRequestEventTargetEventMap {
    "abort": Event;
    "error": ErrorEvent;
    "load": Event;
    "loadend": ProgressEvent;
    "loadstart": Event;
    "progress": ProgressEvent;
    "timeout": ProgressEvent;
}

interface XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap {
    "readystatechange": Event;
}


interface XMLHttpRequest extends EventTarget, XMLHttpRequestEventTarget {
    onreadystatechange: (this: XMLHttpRequest, ev: Event) => any;
    readonly readyState: number;
    readonly response: any;
    readonly responseText: string;
    responseType: 'text' | 'arraybuffer' | '';
    readonly status: number;
    readonly statusText: string;
    timeout: number;
    readonly upload: XMLHttpRequestUpload;
    withCredentials: boolean;
    abort(): void;
    getAllResponseHeaders(): string;
    getResponseHeader(header: string): string | null;
    open(method: string, url: string, async?: boolean, user?: string, password?: string): void;
    send(data?: string): void;
    send(data?: any): void;
    setRequestHeader(header: string, value: string): void;
    readonly DONE: number;
    readonly HEADERS_RECEIVED: number;
    readonly LOADING: number;
    readonly OPENED: number;
    readonly UNSENT: number;
    addEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, useCapture?: boolean): void;
    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
}

declare var XMLHttpRequest: {
    prototype: XMLHttpRequest;
    new(): XMLHttpRequest;
    readonly DONE: number;
    readonly HEADERS_RECEIVED: number;
    readonly LOADING: number;
    readonly OPENED: number;
    readonly UNSENT: number;
}

interface XMLHttpRequestUpload extends EventTarget, XMLHttpRequestEventTarget {
    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, useCapture?: boolean): void;
    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
}

declare var XMLHttpRequestUpload: {
    prototype: XMLHttpRequestUpload;
    new(): XMLHttpRequestUpload;
}


// $


/**
 * A shortcut to [`tabris.contentView.find()`](./Composite.md#findselector). Returns a collection
 * containing all descendants of contentView that match the given selector. This does *not* include any
 * widgets in the drawer, a popover, or encapsulated in a custom component.
 * @param selector A selector expression or a predicate function to filter the results.
 */
declare function $<Result extends tabris.Widget = tabris.Widget>(selector?: tabris.Selector<tabris.Widget, Result>): tabris.WidgetCollection<Result>;

/**
 * A JSX stateless functional component that groups all given widgets in a WidgetCollection
 * @param attributes This parameter needs to be null since <$> does not support any attributes
 * @param children The widgets to be included in the resulting WidgetCollection instance.
 */
declare function $(attributes: {children: tabris.JSXChildren<tabris.Widget>}|null, children: tabris.JSXChildren<tabris.Widget>): tabris.WidgetCollection<tabris.Widget>;

/**
 * A JSX stateless functional component that joins any given content in to a single string.
 * @param attributes This parameter needs to be null since <$> does not support any attributes.
 * @param children The content of the resulting string.
 */
declare function $(attributes: {children: string|number|boolean|Array<null|string|number|boolean>}|null, children: string|number|boolean|Array<null|string|number|boolean>): string;

/**
 * Returns the non-disposed `NativeObject` instance (e.g. a widget) associated with the given cid
 * number. The number can be obtained via the [cid](./NativeObject.md#cid) property. Example: If the cid
 * of an object is `'$23'` it can be obtained by `$(23)`. The cid is visible in the log when passing a
 * NativeObject to any log method, e.g. [`console.log(widget)`](./console.md#logvalues), or
 * [`console.dirxml(widget)`](./console.md#dirxmlobject). The native object may then be obtained using
 * the developer console or the interactive console feature for the tabris CLI serve command.
 * This feature is meant for debugging purposes only. **Using it in production code is dangerous since
 * it allows interfering with the internals of the framework or encapsulated components.** Also, the
 * `cid` of a NativeObject is not stable, meaning it can change each time the code is executed.
 * @param cidNumber The cid number is the trailing part of the [cid](./NativeObject.md#cid) property string.
 */
declare function $(cidNumber: number): tabris.NativeObject;

// Console

/**
 * The console object provides access to the debugging console
 */
declare class Console {

  private constructor();

  /**
   * Outputs an error message to the console if the first argument is false.
   * @param expression Any boolean expression. If the assertion is false, the error message is written to the console.
   * @param values A list of JavaScript values to output.
   */
  assert(expression: boolean, ...values: any[]): void;

  /**
   * Logs the number of times that this particular call to count() has been called.
   * @param label If supplied, count() outputs the number of times it has been called with that label.
   */
  count(label?: string): void;

  /**
   * Resets the counter.
   * @param label If label supplied, this function resets the count associated with that particular label.
   */
  countReset(label?: string): void;

  /**
   * Outputs a debug message to the console.
   * @param values A list of JavaScript values to output.
   */
  debug(...values: any[]): void;

  /**
   * XML tree representation of a given object, if available. Supported types include all widgets and
   * `localStorage`. 
   * *The output is NOT JSX, it is a human-readable summary that displays XML-conforming string
   * representations of some select property values.
   * @param object A JavaScript object
   */
  dirxml(object: any): void;

  /**
   * Outputs an error message to the console.
   * @param values A list of JavaScript values to output.
   */
  error(...values: any[]): void;

  /**
   * Creates a new inline group in the console output. This indents following console messages by an
   * additional spaces, until console.groupEnd() is called.
   * @param values A list of JavaScript values to output.
   */
  group(...values: any[]): void;

  /**
   * Exits the current inline group in the console.
   */
  groupEnd(): void;

  /**
   * Exits the current inline group in the console.
   */
  groupEnd(): void;

  /**
   * Outputs an info message to the console.
   * @param values A list of JavaScript values to output.
   */
  info(...values: any[]): void;

  /**
   * Outputs a message to the console.
   * @param values A list of JavaScript values to output
   */
  log(...values: any[]): void;

  /**
   * Prints a stack trace in a platform-independent format. Framework internals are omitted.
   * Source maps are supported when side-loading code via the tabris CLI.
   */
  trace(): void;

  /**
   * Outputs a warning message to the console.
   * @param values A list of JavaScript values to output.
   */
  warn(...values: any[]): void;
}

declare var console: Console;

// Storage

/**
 * The `localStorage` object allows storing key-value pairs in a persistent store. Both keys and values
 * are stored as strings.
 * On iOS, there is an additional object `secureStorage` available in the global scope. This is a
 * drop-in replacement for `localStorage` that keeps data in the encrypted iOS Keychain.
 * The `localStorage` is only meant to store relatively short strings. To store larger amounts of data
 * it is recommended to use the [FileSystem](./fs.html) API.
 */
declare class Storage {

  private constructor();

  /**
   * Remove all key/value pairs from the storage.
   */
  clear(): void;

  /**
   * Retrieves the value associated with the given key.
   * @param key
   */
  getItem(key: string): string|null;

  /**
   * Returns the name of the key at the given index in the storage. The order of keys is platform
   * dependent, you should not rely on it to be deterministic
   * @param index
   */
  key(index: number): string;

  /**
   * Removes the given key/value pair from the storage.
   * @param key
   */
  removeItem(key: string): void;

  /**
   * Stores a string value using the given key.
   * @param key
   * @param value
   */
  setItem(key: string, value: string): void;

  /**
   * The number of items in the storage.
   * @constant
   */
  readonly length: number;
}

declare var localStorage: Storage;

// Timer


/**
 * Cancels the running interval associated with the given ID. When given an invalid ID, nothing happens.
 * @param id The ID that was returned by `setInterval`.
 */
declare function clearInterval(id: any): void;

/**
 * Cancels the running timeout associated with the given ID. When given an invalid ID, nothing happens.
 * @param id The ID that was returned by `setTimeout`.
 */
declare function clearTimeout(id: any): void;

/**
 * Calls the given function repeatedly, each times waiting the given delay. The actual delay may be
 * slightly longer than the given one.
 * @param callback The function to call.
 * @param delay The delay in milliseconds.
 * @param params One or more values passed on to the callback.
 */
declare function setInterval(callback: Function, delay?: number, ...params: any[]): any;

/**
 * Calls the given function with `param` (and all following parameters) after the specified delay. The
 * actual delay may be slightly longer than the given one.
 * @param callback The function to call.
 * @param delay The delay in milliseconds.
 * @param params One or more values passed on to the callback.
 */
declare function setTimeout(callback: Function, delay?: number, ...params: any[]): any;

